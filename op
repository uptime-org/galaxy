#!/bin/bash
set -e

SERVICE="galaxy"
NAMESPACE="local"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CI_IMAGE_NAME="bandy-ci"
REGISTRY="gcr.io/your-project"  # Configure your registry

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Generate unique image tag
get_image_tag() {
    local env="${1:-dev}"
    if [[ "$env" == "local" || "$env" == "dev" ]]; then
        # For local development, use git hash + timestamp
        local git_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        local timestamp=$(date +"%Y%m%d-%H%M%S")
        echo "${env}-${git_hash}-${timestamp}"
    else
        # For production, use git hash only
        git rev-parse --short HEAD 2>/dev/null || echo "latest"
    fi
}

# Get full image name
get_image_name() {
    local env="${1:-dev}"
    local tag=$(get_image_tag "$env")
    if [[ "$env" == "local" || "$env" == "dev" ]]; then
        echo "$SERVICE:$tag"
    else
        echo "$REGISTRY/$SERVICE:$tag"
    fi
}

# Check if gh CLI is available
check_gh_cli() {
    if ! command -v gh >/dev/null 2>&1; then
        echo -e "${RED}‚ùå GitHub CLI (gh) not found. Install it with: brew install gh${NC}"
        return 1
    fi
    if ! gh auth status >/dev/null 2>&1; then
        echo -e "${RED}‚ùå Not authenticated with GitHub. Run: gh auth login${NC}"
        return 1
    fi
    return 0
}

show_help() {
    echo -e "${BLUE}Galaxy Service Control Plane${NC}"
    echo -e "${PURPLE}Unified operations for Galaxy microservices ecosystem${NC}"
    echo ""
    echo -e "${YELLOW}Service Management:${NC}"
    echo "  build [env] [--clean] Build service image for environment (local/dev/stage/prod)"
    echo "  push [env]            Push service image to registry"
    echo "  deploy [env]          Deploy service to k8s environment"
    echo "  run [env] [--clean]   Build + Deploy service (--clean = no cache)"
    echo "  validate              Validate shared infrastructure and service environment"
    echo ""
    echo -e "${YELLOW}Infrastructure Management:${NC}"
    echo "  images                List service images across environments"
    echo "  clean                 Clean up old service images"
    echo ""
    echo -e "${YELLOW}Quality Assurance:${NC}"
    echo "  test                  Run full CI analysis"
    echo "  test --target TARGET  Run specific target (python|helm|all)"
    echo "  test --tests TESTS    Run specific tests (security|safety|unit|all)"
    echo "  test --lint LINT      Run specific linting (flake8|black|isort|helm|all)"
    echo ""
    echo -e "${YELLOW}Pipeline Management:${NC}"
    echo "  actions               Show recent workflow runs"
    echo "  actions status        Show current pipeline status"
    echo "  actions logs [run_id] Show workflow logs"
    echo "  actions summary       Show pipeline health summary"
    echo "  actions failures      Show recent failure details"
    echo "  actions debug         Debug latest failed run"
    echo "  actions fix           Suggest fixes for common issues"
    echo "  actions --watch       Watch workflow runs in real-time"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  ./op run local --clean  # Clean build and deploy service locally"
    echo "  ./op push stage         # Push service to staging registry"
    echo "  ./op test --target python --lint flake8"
    echo "  ./op actions --watch    # Monitor ecosystem CI/CD pipelines"
    echo "  ./op validate           # Validate shared infrastructure"
}

run_ci_tests() {
    echo -e "${BLUE}üê≥ Building CI container...${NC}"
    docker build -f ci-test/Dockerfile -t "$CI_IMAGE_NAME" .
    
    # Run with provided arguments or default to full analysis
    if [ $# -eq 0 ]; then
        echo -e "${BLUE}üîÑ Running full analysis (no arguments provided)...${NC}"
        docker run --rm -v "$SCRIPT_DIR/ci-test/reports:/app/ci-test/reports" "$CI_IMAGE_NAME"
    else
        echo -e "${BLUE}üöÄ Running with custom parameters: $@${NC}"
        docker run --rm -v "$SCRIPT_DIR/ci-test/reports:/app/ci-test/reports" "$CI_IMAGE_NAME" "$@"
    fi
    
    # Show results
    if [ -d "$SCRIPT_DIR/ci-test/reports" ]; then
        echo ""
        echo -e "${GREEN}üìä Reports available in: $SCRIPT_DIR/ci-test/reports${NC}"
        ls -la "$SCRIPT_DIR/ci-test/reports"
    fi
}

run_validation() {
    echo -e "${BLUE}üß™ Galaxy Service Environment Validation${NC}"
    echo -e "${PURPLE}Validating shared infrastructure for microservices${NC}"
    echo "================================================"
    
    # Check Docker
    echo -n "üì¶ Docker: "
    if docker ps >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Running${NC}"
    else
        echo -e "${RED}‚ùå Not running - Start Docker Desktop first${NC}"
        return 1
    fi
    
    # Check k8s
    echo -n "‚éà Kubernetes: "
    if kubectl cluster-info >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Connected${NC}"
        CONTEXT=$(kubectl config current-context)
        echo "   Context: $CONTEXT"
    else
        echo -e "${RED}‚ùå Not connected - Enable k8s in Docker Desktop${NC}"
        return 1
    fi
    
    # Check Helm
    echo -n "üõµ Helm: "
    if command -v helm >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Available${NC}"
    else
        echo -e "${RED}‚ùå Not found - Install Helm${NC}"
        return 1
    fi
    
    # Check ingress controller (optional)
    echo -n "üåê Ingress Controller: "
    if kubectl get pods -n ingress-nginx >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Available${NC}"
        INGRESS_AVAILABLE=true
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Not found (optional - see docs/SETUP.md)${NC}"
        INGRESS_AVAILABLE=false
    fi
    
    echo ""
    echo -e "${BLUE}üß™ Testing Service Deployment...${NC}"
    
    # Test CI
    echo "1. Running tests..."
    if $0 test >/dev/null 2>&1; then
        echo -e "   ${GREEN}‚úÖ Tests passed${NC}"
    else
        echo -e "   ${YELLOW}‚ö†Ô∏è  Tests had issues (check ci-test/reports/)${NC}"
    fi
    
    # Test build and deploy (use consistent tagging like run command)
    echo "2. Building and deploying..."
    if $0 run local >/dev/null 2>&1; then
        echo -e "   ${GREEN}‚úÖ Built and deployed successfully${NC}"
        # Show the actual image that was built
        LATEST_IMAGE=$(docker images galaxy --format "table {{.Repository}}:{{.Tag}}" | grep local | head -1)
        echo -e "   ${BLUE}üì¶ Image: $LATEST_IMAGE${NC}"
    else
        echo -e "   ${RED}‚ùå Build/Deploy failed${NC}"
        return 1
    fi
    
    # Test access
    echo "3. Testing access..."
    sleep 5  # Wait for pod to be ready
    
    if $INGRESS_AVAILABLE; then
        echo "   Testing ingress access..."
        if kubectl get ingress -n local galaxy-local >/dev/null 2>&1; then
            echo -e "   ${GREEN}‚úÖ Ingress created${NC}"
            echo -e "   ${BLUE}üìù Add to /etc/hosts: echo '127.0.0.1 galaxy-local.localhost' | sudo tee -a /etc/hosts${NC}"
            echo -e "   ${BLUE}üåê Then visit: http://galaxy-local.localhost${NC}"
        fi
    else
        echo "   Testing service access..."
        if kubectl get svc -n local galaxy-local >/dev/null 2>&1; then
            echo -e "   ${GREEN}‚úÖ Service created${NC}"
            echo -e "   ${BLUE}üîå Access via: kubectl port-forward -n local svc/galaxy-local 8080:80${NC}"
            echo -e "   ${BLUE}üåê Then visit: http://localhost:8080${NC}"
        fi
    fi
    
    # Show status
    echo ""
    echo -e "${BLUE}üìä Current Status:${NC}"
    kubectl get pods,svc,ingress -n local 2>/dev/null || echo "No resources found"
    
    echo ""
    echo -e "${GREEN}‚úÖ Service Infrastructure Validation Complete!${NC}"
    echo ""
    echo -e "${BLUE}üöÄ Service Management Commands:${NC}"
    echo "   ./op run --clean    # Clean build and deploy service"
    echo "   kubectl logs -n local -l app.kubernetes.io/name=galaxy -f  # View service logs"
    echo "   helm uninstall galaxy-local -n local  # Clean up service"
}

case "${1}" in
    test)
        echo -e "${YELLOW}üß™ Running tests...${NC}"
        run_ci_tests "${@:2}"
        ;;
    
    build)
        ENV="${2:-local}"
        IMAGE_NAME=$(get_image_name "$ENV")
        
        if [[ "${3}" == "--clean" || "${2}" == "--clean" ]]; then
            echo -e "${YELLOW}üèóÔ∏è  Building $IMAGE_NAME (no cache)...${NC}"
            docker build --no-cache -t "$IMAGE_NAME" .
        else
            echo -e "${YELLOW}üèóÔ∏è  Building $IMAGE_NAME...${NC}"
            docker build -t "$IMAGE_NAME" .
        fi
        echo -e "${GREEN}‚úÖ Built $IMAGE_NAME${NC}"
        echo -e "${BLUE}üìù Use with: ./op deploy $ENV${NC}"
        ;;
    
    push)
        ENV="${2:-stage}"
        if [[ "$ENV" == "local" ]]; then
            echo -e "${RED}‚ùå Cannot push local images. Use: $0 push [dev|stage|prod]${NC}"
            exit 1
        fi
        
        IMAGE_NAME=$(get_image_name "$ENV")
        echo -e "${YELLOW}üì§ Pushing $IMAGE_NAME...${NC}"
        
        # Build if not exists
        if ! docker images "$IMAGE_NAME" --format "table {{.Repository}}:{{.Tag}}" | grep -q "$IMAGE_NAME"; then
            echo -e "${BLUE}üèóÔ∏è  Image not found, building first...${NC}"
            $0 build "$ENV"
        fi
        
        docker push "$IMAGE_NAME"
        echo -e "${GREEN}‚úÖ Pushed $IMAGE_NAME${NC}"
        ;;
    
    deploy)
        ENV="${2:-local}"
        case "$ENV" in
            local)
                IMAGE_TAG=$(get_image_tag "local")
                NAMESPACE="local"
                VALUES_FILE="./helm/env/local.values.yaml"
                PULL_POLICY="Never"
                ;;
            dev|stage|prod)
                IMAGE_TAG=$(get_image_tag "$ENV")
                NAMESPACE="$ENV"
                VALUES_FILE="./helm/env/$ENV.values.yaml"
                PULL_POLICY="Always"
                ;;
            *)
                echo -e "${RED}‚ùå Unknown environment: $ENV. Use: local|dev|stage|prod${NC}"
                exit 1
                ;;
        esac
        
        echo -e "${YELLOW}üöÄ Deploying to $ENV environment...${NC}"
        
        # Fix team extraction from CODEOWNERS
        TEAM=$(grep "^\* @" .github/CODEOWNERS | head -1 | sed 's/^\* @//' | awk '{print $1}' 2>/dev/null || echo "dev-team")
        
        # For local development, ensure required secret exists
        if [[ "$ENV" == "local" ]]; then
            echo -e "${BLUE}üîí Ensuring local development secret exists...${NC}"
            
            # Create namespace if it doesn't exist
            kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f - >/dev/null 2>&1
            
            # Check if secret exists, create if not
            if ! kubectl get secret "$SERVICE-$ENV-secrets" -n "$NAMESPACE" >/dev/null 2>&1; then
                echo -e "${YELLOW}üìù Creating $SERVICE-$ENV-secrets secret...${NC}"
                kubectl create secret generic "$SERVICE-$ENV-secrets" \
                    --from-literal=password="local-dev-password-$(date +%s)" \
                    -n "$NAMESPACE"
                echo -e "${GREEN}‚úÖ Secret created for local development${NC}"
            else
                echo -e "${BLUE}üìù Secret $SERVICE-$ENV-secrets already exists${NC}"
            fi
        fi
        
        helm upgrade --install "$SERVICE-$ENV" ./helm \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --values ./helm/values.yaml \
            --values "$VALUES_FILE" \
            --set env="$ENV" \
            --set service.name="$SERVICE" \
            --set image.repository="$(echo $SERVICE | cut -d':' -f1)" \
            --set image.tag="$IMAGE_TAG" \
            --set image.pullPolicy="$PULL_POLICY" \
            --set team="$TEAM" \
            --wait
            
        if [[ "$ENV" == "local" ]]; then
            echo -e "${GREEN}‚úÖ Deployed! Access: http://galaxy-local.localhost (or add to /etc/hosts)${NC}"
        else
            echo -e "${GREEN}‚úÖ Deployed to $ENV environment!${NC}"
        fi
        ;;
    
    run)
        ENV="${2:-local}"
        CLEAN_FLAG="${3:-${2}}"
        
        # Generate image tag once to ensure consistency between build and deploy
        IMAGE_TAG=$(get_image_tag "$ENV")
        IMAGE_NAME=$(get_image_name "$ENV")
        
        # Build with specific tag
        if [[ "$CLEAN_FLAG" == "--clean" ]]; then
            echo -e "${YELLOW}üèóÔ∏è  Building $IMAGE_NAME (no cache)...${NC}"
            docker build --no-cache -t "$IMAGE_NAME" .
        else
            echo -e "${YELLOW}üèóÔ∏è  Building $IMAGE_NAME...${NC}"
            docker build -t "$IMAGE_NAME" .
        fi
        echo -e "${GREEN}‚úÖ Built $IMAGE_NAME${NC}"
        
        # Deploy with same tag
        case "$ENV" in
            local)
                NAMESPACE="local"
                VALUES_FILE="./helm/env/local.values.yaml"
                PULL_POLICY="Never"
                ;;
            dev|stage|prod)
                NAMESPACE="$ENV"
                VALUES_FILE="./helm/env/$ENV.values.yaml"
                PULL_POLICY="Always"
                ;;
            *)
                echo -e "${RED}‚ùå Unknown environment: $ENV. Use: local|dev|stage|prod${NC}"
                exit 1
                ;;
        esac
        
        echo -e "${YELLOW}üöÄ Deploying to $ENV environment...${NC}"
        
        # Fix team extraction from CODEOWNERS
        TEAM=$(grep "^\* @" .github/CODEOWNERS | head -1 | sed 's/^\* @//' | awk '{print $1}' 2>/dev/null || echo "dev-team")
        
        # For local development, ensure required secret exists and manage port-forwarding
        if [[ "$ENV" == "local" ]]; then
            echo -e "${BLUE}üîí Ensuring local development secret exists...${NC}"
            
            # Create namespace if it doesn't exist
            kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f - >/dev/null 2>&1
            
            # Check if secret exists, create if not
            if ! kubectl get secret "$SERVICE-$ENV-secrets" -n "$NAMESPACE" >/dev/null 2>&1; then
                echo -e "${YELLOW}üìù Creating $SERVICE-$ENV-secrets secret...${NC}"
                kubectl create secret generic "$SERVICE-$ENV-secrets" \
                    --from-literal=password="local-dev-password-$(date +%s)" \
                    -n "$NAMESPACE"
                echo -e "${GREEN}‚úÖ Secret created for local development${NC}"
            else
                echo -e "${BLUE}üìù Secret $SERVICE-$ENV-secrets already exists${NC}"
            fi
            
            # Defensively kill any existing port-forwards for this service
            echo -e "${BLUE}üõ°Ô∏è  Cleaning up existing port-forwards...${NC}"
            pkill -f "kubectl.*port-forward.*galaxy-local" 2>/dev/null || true
            # Also kill any port-forwards on port 5000
            lsof -ti:5000 | xargs kill -9 2>/dev/null || true
        fi
        
        helm upgrade --install "$SERVICE-$ENV" ./helm \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --values ./helm/values.yaml \
            --values "$VALUES_FILE" \
            --set env="$ENV" \
            --set service.name="$SERVICE" \
            --set image.repository="$(echo $SERVICE | cut -d':' -f1)" \
            --set image.tag="$IMAGE_TAG" \
            --set image.pullPolicy="$PULL_POLICY" \
            --set team="$TEAM" \
            --wait
            
        if [[ "$ENV" == "local" ]]; then
            echo -e "${GREEN}‚úÖ Deployed successfully!${NC}"
            
            # Wait for pod to be ready before starting port-forward
            echo -e "${BLUE}‚è≥ Waiting for pod to be ready...${NC}"
            kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=galaxy -n local --timeout=60s >/dev/null 2>&1
            
            # Start background port-forwarding
            echo -e "${BLUE}üîó Starting background port-forward on port 5000...${NC}"
            nohup kubectl port-forward -n local svc/galaxy-local 5000:5000 >/dev/null 2>&1 &
            PORT_FORWARD_PID=$!
            
            # Give it a moment to establish
            sleep 2
            
            # Check if port-forward is working
            if curl -s --max-time 3 http://localhost:5000/health >/dev/null 2>&1; then
                echo -e "${GREEN}‚úÖ Service ready! Access at: http://localhost:5000${NC}"
                echo -e "${BLUE}üìù Health check: http://localhost:5000/health${NC}"
                echo -e "${YELLOW}üìù Port-forward PID: $PORT_FORWARD_PID (will run in background)${NC}"
            else
                echo -e "${YELLOW}‚ö†Ô∏è  Service deployed but not yet ready. Try: http://localhost:5000 in a moment${NC}"
            fi
        else
            echo -e "${GREEN}‚úÖ Deployed to $ENV environment!${NC}"
        fi
        ;;
    
    images)
        echo -e "${BLUE}üê≥ Service Docker Images:${NC}"
        docker images "$SERVICE" --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedSince}}"
        echo ""
        echo -e "${BLUE}üóÇÔ∏è  Registry Images:${NC}"
        docker images "$REGISTRY/$SERVICE" --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedSince}}" 2>/dev/null || echo "No registry images found locally"
        ;;
    
    clean)
        echo -e "${YELLOW}üßπ Cleaning up old service images...${NC}"
        # Keep last 5 local images
        OLD_IMAGES=$(docker images "$SERVICE" --format "{{.Repository}}:{{.Tag}}" | tail -n +6)
        if [[ -n "$OLD_IMAGES" ]]; then
            echo "$OLD_IMAGES" | xargs docker rmi
            echo -e "${GREEN}‚úÖ Cleaned up old images${NC}"
        else
            echo -e "${BLUE}üìù No old images to clean${NC}"
        fi
        ;;
    
    actions)
        if ! check_gh_cli; then
            exit 1
        fi
        
        case "${2}" in
            status)
                echo -e "${PURPLE}üîÑ Pipeline Status${NC}"
                echo "=================="
                gh run list --limit 1 --json status,conclusion,displayTitle,createdAt,url --template '
                {{- range . -}}
                üîç Status: {{.status}}
                üéØ Result: {{.conclusion}}
                üìù Title: {{.displayTitle}}
                üïí Started: {{.createdAt}}
                üîó URL: {{.url}}
                {{- end -}}'
                ;;
            logs)
                RUN_ID="${3}"
                if [[ -z "$RUN_ID" ]]; then
                    RUN_ID=$(gh run list --limit 1 --json databaseId --jq '.[0].databaseId')
                fi
                echo -e "${BLUE}üìú Fetching logs for run $RUN_ID...${NC}"
                gh run view "$RUN_ID" --log
                ;;
            summary)
                echo -e "${PURPLE}üìä Pipeline Health Summary${NC}"
                echo "============================"
                echo -e "${BLUE}Last 10 runs:${NC}"
                gh run list --limit 10 --json status,conclusion --jq '
                "Success: \(map(select(.conclusion == "success")) | length)" ,
                "Failed: \(map(select(.conclusion == "failure")) | length)" ,
                "Pending: \(map(select(.status == "in_progress" or .status == "queued")) | length)"
                '
                echo -e "${GREEN}‚úÖ Success runs shown above${NC}"
                echo -e "${RED}‚ùå Failed runs shown above${NC}"
                echo -e "${YELLOW}üü° Pending runs shown above${NC}"
                ;;
            failures)
                echo -e "${RED}üêõ Recent Failures Analysis${NC}"
                echo "=============================="
                echo -e "${BLUE}Failed runs with details:${NC}"
                gh run list --limit 5 --json status,conclusion,displayTitle,createdAt,url,databaseId --jq '
                .[] | select(.conclusion == "failure") | 
                "ID: \(.databaseId)\nTitle: \(.displayTitle)\nTime: \(.createdAt)\nURL: \(.url)\n---"
                '
                echo -e "${YELLOW}üí° Use './op actions debug' for detailed failure analysis${NC}"
                ;;
            debug)
                echo -e "${RED}üîç Debugging Latest Build${NC}"
                echo "======================="
                LATEST_RUN_ID=$(gh run list --limit 1 --json databaseId --jq '.[0].databaseId')
                if [[ -n "$LATEST_RUN_ID" ]]; then
                    echo -e "${BLUE}Analyzing latest run $LATEST_RUN_ID...${NC}"
                    echo ""
                    echo -e "${YELLOW}Run details:${NC}"
                    gh run view "$LATEST_RUN_ID" --json status,conclusion,displayTitle,createdAt --jq '
                    "üîç Status: \(.status)\nüéØ Result: \(.conclusion)\nüìù Title: \(.displayTitle)\nüïí Started: \(.createdAt)"
                    '
                    echo ""
                    echo -e "${YELLOW}Jobs and their status:${NC}"
                    gh run view "$LATEST_RUN_ID" --json jobs --jq '.jobs[] | "Job: \(.name) - Status: \(.conclusion)"'
                    echo ""
                    # Show logs for failed jobs, or all logs if run failed
                    RUN_STATUS=$(gh run view "$LATEST_RUN_ID" --json conclusion --jq '.conclusion')
                    if [[ "$RUN_STATUS" == "failure" ]]; then
                        echo -e "${YELLOW}Failed job logs:${NC}"
                        gh run view "$LATEST_RUN_ID" --log-failed
                    else
                        echo -e "${GREEN}Run completed successfully!${NC}"
                        echo -e "${BLUE}Use './op actions logs $LATEST_RUN_ID' for full logs${NC}"
                    fi
                else
                    echo -e "${BLUE}No runs found${NC}"
                fi
                ;;
            fix)
                echo -e "${GREEN}üîß Common CI Issue Fixes${NC}"
                echo "========================="
                echo -e "${BLUE}Analyzing recent failures...${NC}"
                RECENT_LOGS=$(gh run list --limit 1 --json conclusion,databaseId --jq '.[] | select(.conclusion == "failure") | .databaseId' | head -1)
                if [[ -n "$RECENT_LOGS" ]]; then
                    FAILURE_CONTENT=$(gh run view "$RECENT_LOGS" --log-failed 2>/dev/null | tail -20)
                    if echo "$FAILURE_CONTENT" | grep -q "denied.*organization package"; then
                        echo ""
                        echo -e "${RED}üêõ Issue: GitHub Container Registry Permission Denied${NC}"
                        echo -e "${YELLOW}The CI is trying to push to ghcr.io but lacks permissions.${NC}"
                        echo ""
                        echo -e "${GREEN}üîß Fixes:${NC}"
                        echo "1. Update GitHub Actions permissions:"
                        echo "   ‚Ä¢ Go to Settings > Actions > General"
                        echo "   ‚Ä¢ Set 'Workflow permissions' to 'Read and write permissions'"
                        echo ""
                        echo "2. Or update the workflow to not push to registry:"
                        echo "   ‚Ä¢ Set push: false in the docker build action"
                        echo ""
                        echo "3. Or use personal access token:"
                        echo "   ‚Ä¢ Add GHCR_TOKEN secret with package write permissions"
                        echo ""
                        echo -e "${PURPLE}üìù Quick fix: Disable push for now${NC}"
                        echo "Edit .github/workflows/deploy.yml and set 'push: false'"
                    else
                        echo -e "${BLUE}No specific fix pattern detected. Check logs with './op actions debug'${NC}"
                    fi
                else
                    echo -e "${BLUE}No recent failures to analyze${NC}"
                fi
                ;;
            --watch)
                echo -e "${PURPLE}üëÄ Watching ecosystem CI/CD pipelines...${NC}"
                gh run watch
                ;;
            *)
                echo -e "${PURPLE}üîÑ Recent Workflow Runs${NC}"
                echo "========================="
                echo ""
                echo -e "${BLUE}üìä Last 10 runs:${NC}"
                gh run list --limit 10
                echo ""
                echo -e "${YELLOW}üí° Commands: status | logs [run_id] | summary | failures | debug | fix | --watch${NC}"
                ;;
        esac
        ;;
    
    validate)
        echo -e "${YELLOW}üîç Running full environment validation...${NC}"
        run_validation
        ;;
    
    help|--help|-h)
        show_help
        ;;
    
    *)
        show_help
        ;;
esac