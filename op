#!/bin/bash
set -e

SERVICE="galaxy"
NAMESPACE="local"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CI_IMAGE_NAME="bandy-ci"
REGISTRY="gcr.io/your-project"  # Configure your registry

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Generate unique image tag
get_image_tag() {
    local env="${1:-dev}"
    if [[ "$env" == "local" || "$env" == "dev" ]]; then
        # For local development, use git hash + timestamp
        local git_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        local timestamp=$(date +"%Y%m%d-%H%M%S")
        echo "${env}-${git_hash}-${timestamp}"
    else
        # For production, use git hash only
        git rev-parse --short HEAD 2>/dev/null || echo "latest"
    fi
}

# Get full image name
get_image_name() {
    local env="${1:-dev}"
    local tag=$(get_image_tag "$env")
    if [[ "$env" == "local" || "$env" == "dev" ]]; then
        echo "$SERVICE:$tag"
    else
        echo "$REGISTRY/$SERVICE:$tag"
    fi
}

# Check if gh CLI is available
check_gh_cli() {
    if ! command -v gh >/dev/null 2>&1; then
        echo -e "${RED}‚ùå GitHub CLI (gh) not found. Install it with: brew install gh${NC}"
        return 1
    fi
    if ! gh auth status >/dev/null 2>&1; then
        echo -e "${RED}‚ùå Not authenticated with GitHub. Run: gh auth login${NC}"
        return 1
    fi
    return 0
}

show_help() {
    echo -e "${BLUE}Galaxy Service Control Plane${NC}"
    echo -e "${PURPLE}Unified operations for Galaxy microservices ecosystem${NC}"
    echo ""
    echo -e "${YELLOW}Service Management:${NC}"
    echo "  build [env] [--clean] Build service image for environment (local/dev/stage/prod)"
    echo "  push [env]            Push service image to registry"
    echo "  deploy [env]          Deploy service to k8s environment"
    echo "  run [env] [--clean]   Build + Deploy service (--clean = no cache)"
    echo "  validate              Validate shared infrastructure and service environment"
    echo ""
    echo -e "${YELLOW}Infrastructure Management:${NC}"
    echo "  images                List service images across environments"
    echo "  clean                 Clean up old service images"
    echo ""
    echo -e "${YELLOW}Quality Assurance:${NC}"
    echo "  test                  Run full CI analysis"
    echo "  test --target TARGET  Run specific target (python|helm|all)"
    echo "  test --tests TESTS    Run specific tests (security|safety|unit|all)"
    echo "  test --lint LINT      Run specific linting (flake8|black|isort|helm|all)"
    echo ""
    echo -e "${YELLOW}Pipeline Management:${NC}"
    echo "  actions               Show recent workflow runs"
    echo "  actions status        Show current pipeline status"
    echo "  actions logs [run_id] Show workflow logs"
    echo "  actions summary       Show pipeline health summary"
    echo "  actions --watch       Watch workflow runs in real-time"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  ./op run local --clean  # Clean build and deploy service locally"
    echo "  ./op push stage         # Push service to staging registry"
    echo "  ./op test --target python --lint flake8"
    echo "  ./op actions --watch    # Monitor ecosystem CI/CD pipelines"
    echo "  ./op validate           # Validate shared infrastructure"
}

run_ci_tests() {
    echo -e "${BLUE}üê≥ Building CI container...${NC}"
    docker build -f ci-test/Dockerfile -t "$CI_IMAGE_NAME" .
    
    # Run with provided arguments or default to full analysis
    if [ $# -eq 0 ]; then
        echo -e "${BLUE}üîÑ Running full analysis (no arguments provided)...${NC}"
        docker run --rm -v "$SCRIPT_DIR/ci-test/reports:/app/ci-test/reports" "$CI_IMAGE_NAME"
    else
        echo -e "${BLUE}üöÄ Running with custom parameters: $@${NC}"
        docker run --rm -v "$SCRIPT_DIR/ci-test/reports:/app/ci-test/reports" "$CI_IMAGE_NAME" "$@"
    fi
    
    # Show results
    if [ -d "$SCRIPT_DIR/ci-test/reports" ]; then
        echo ""
        echo -e "${GREEN}üìä Reports available in: $SCRIPT_DIR/ci-test/reports${NC}"
        ls -la "$SCRIPT_DIR/ci-test/reports"
    fi
}

run_validation() {
    echo -e "${BLUE}üß™ Galaxy Service Environment Validation${NC}"
    echo -e "${PURPLE}Validating shared infrastructure for microservices${NC}"
    echo "================================================"
    
    # Check Docker
    echo -n "üì¶ Docker: "
    if docker ps >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Running${NC}"
    else
        echo -e "${RED}‚ùå Not running - Start Docker Desktop first${NC}"
        return 1
    fi
    
    # Check k8s
    echo -n "‚éà Kubernetes: "
    if kubectl cluster-info >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Connected${NC}"
        CONTEXT=$(kubectl config current-context)
        echo "   Context: $CONTEXT"
    else
        echo -e "${RED}‚ùå Not connected - Enable k8s in Docker Desktop${NC}"
        return 1
    fi
    
    # Check Helm
    echo -n "üõµ Helm: "
    if command -v helm >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Available${NC}"
    else
        echo -e "${RED}‚ùå Not found - Install Helm${NC}"
        return 1
    fi
    
    # Check ingress controller (optional)
    echo -n "üåê Ingress Controller: "
    if kubectl get pods -n ingress-nginx >/dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ Available${NC}"
        INGRESS_AVAILABLE=true
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Not found (optional - see docs/SETUP.md)${NC}"
        INGRESS_AVAILABLE=false
    fi
    
    echo ""
    echo -e "${BLUE}üß™ Testing Service Deployment...${NC}"
    
    # Test CI
    echo "1. Running tests..."
    if $0 test >/dev/null 2>&1; then
        echo -e "   ${GREEN}‚úÖ Tests passed${NC}"
    else
        echo -e "   ${YELLOW}‚ö†Ô∏è  Tests had issues (check ci-test/reports/)${NC}"
    fi
    
    # Test build
    echo "2. Building image..."
    if $0 build >/dev/null 2>&1; then
        echo -e "   ${GREEN}‚úÖ Image built: galaxy:dev${NC}"
        docker images galaxy:dev --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedSince}}"
    else
        echo -e "   ${RED}‚ùå Build failed${NC}"
        return 1
    fi
    
    # Test deploy
    echo "3. Deploying to k8s..."
    if $0 deploy 2>&1 | grep -q "Deployed"; then
        echo -e "   ${GREEN}‚úÖ Deployed to namespace: local${NC}"
    else
        echo -e "   ${RED}‚ùå Deploy failed${NC}"
        return 1
    fi
    
    # Test access
    echo "4. Testing access..."
    sleep 5  # Wait for pod to be ready
    
    if $INGRESS_AVAILABLE; then
        echo "   Testing ingress access..."
        if kubectl get ingress -n local galaxy-local >/dev/null 2>&1; then
            echo -e "   ${GREEN}‚úÖ Ingress created${NC}"
            echo -e "   ${BLUE}üìù Add to /etc/hosts: echo '127.0.0.1 galaxy-local.localhost' | sudo tee -a /etc/hosts${NC}"
            echo -e "   ${BLUE}üåê Then visit: http://galaxy-local.localhost${NC}"
        fi
    else
        echo "   Testing service access..."
        if kubectl get svc -n local galaxy-local >/dev/null 2>&1; then
            echo -e "   ${GREEN}‚úÖ Service created${NC}"
            echo -e "   ${BLUE}üîå Access via: kubectl port-forward -n local svc/galaxy-local 8080:80${NC}"
            echo -e "   ${BLUE}üåê Then visit: http://localhost:8080${NC}"
        fi
    fi
    
    # Show status
    echo ""
    echo -e "${BLUE}üìä Current Status:${NC}"
    kubectl get pods,svc,ingress -n local 2>/dev/null || echo "No resources found"
    
    echo ""
    echo -e "${GREEN}‚úÖ Service Infrastructure Validation Complete!${NC}"
    echo ""
    echo -e "${BLUE}üöÄ Service Management Commands:${NC}"
    echo "   ./op run --clean    # Clean build and deploy service"
    echo "   kubectl logs -n local -l app.kubernetes.io/name=galaxy -f  # View service logs"
    echo "   helm uninstall galaxy-local -n local  # Clean up service"
}

case "${1}" in
    test)
        echo -e "${YELLOW}üß™ Running tests...${NC}"
        run_ci_tests "${@:2}"
        ;;
    
    build)
        ENV="${2:-local}"
        IMAGE_NAME=$(get_image_name "$ENV")
        
        if [[ "${3}" == "--clean" || "${2}" == "--clean" ]]; then
            echo -e "${YELLOW}üèóÔ∏è  Building $IMAGE_NAME (no cache)...${NC}"
            docker build --no-cache -t "$IMAGE_NAME" .
        else
            echo -e "${YELLOW}üèóÔ∏è  Building $IMAGE_NAME...${NC}"
            docker build -t "$IMAGE_NAME" .
        fi
        echo -e "${GREEN}‚úÖ Built $IMAGE_NAME${NC}"
        echo -e "${BLUE}üìù Use with: ./op deploy $ENV${NC}"
        ;;
    
    push)
        ENV="${2:-stage}"
        if [[ "$ENV" == "local" ]]; then
            echo -e "${RED}‚ùå Cannot push local images. Use: $0 push [dev|stage|prod]${NC}"
            exit 1
        fi
        
        IMAGE_NAME=$(get_image_name "$ENV")
        echo -e "${YELLOW}üì§ Pushing $IMAGE_NAME...${NC}"
        
        # Build if not exists
        if ! docker images "$IMAGE_NAME" --format "table {{.Repository}}:{{.Tag}}" | grep -q "$IMAGE_NAME"; then
            echo -e "${BLUE}üèóÔ∏è  Image not found, building first...${NC}"
            $0 build "$ENV"
        fi
        
        docker push "$IMAGE_NAME"
        echo -e "${GREEN}‚úÖ Pushed $IMAGE_NAME${NC}"
        ;;
    
    deploy)
        ENV="${2:-local}"
        case "$ENV" in
            local)
                IMAGE_TAG=$(get_image_tag "local")
                NAMESPACE="local"
                VALUES_FILE="./helm/env/local.values.yaml"
                PULL_POLICY="Never"
                ;;
            dev|stage|prod)
                IMAGE_TAG=$(get_image_tag "$ENV")
                NAMESPACE="$ENV"
                VALUES_FILE="./helm/env/$ENV.values.yaml"
                PULL_POLICY="Always"
                ;;
            *)
                echo -e "${RED}‚ùå Unknown environment: $ENV. Use: local|dev|stage|prod${NC}"
                exit 1
                ;;
        esac
        
        echo -e "${YELLOW}üöÄ Deploying to $ENV environment...${NC}"
        TEAM=$(grep "^\\* @" .github/CODEOWNERS | head -1 | sed 's/^\\* @//' | awk '{print $1}' || echo "dev-team")
        
        helm upgrade --install "$SERVICE-$ENV" ./helm \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --values ./helm/values.yaml \
            --values "$VALUES_FILE" \
            --set env="$ENV" \
            --set service.name="$SERVICE" \
            --set image.repository="$(echo $SERVICE | cut -d':' -f1)" \
            --set image.tag="$IMAGE_TAG" \
            --set image.pullPolicy="$PULL_POLICY" \
            --set team="$TEAM" \
            --wait
            
        if [[ "$ENV" == "local" ]]; then
            echo -e "${GREEN}‚úÖ Deployed! Access: http://galaxy-local.localhost (or add to /etc/hosts)${NC}"
        else
            echo -e "${GREEN}‚úÖ Deployed to $ENV environment!${NC}"
        fi
        ;;
    
    run)
        ENV="${2:-local}"
        CLEAN_FLAG="${3:-${2}}"
        if [[ "$CLEAN_FLAG" == "--clean" ]]; then
            $0 build "$ENV" --clean
        else
            $0 build "$ENV"
        fi
        $0 deploy "$ENV"
        ;;
    
    images)
        echo -e "${BLUE}üê≥ Service Docker Images:${NC}"
        docker images "$SERVICE" --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedSince}}"
        echo ""
        echo -e "${BLUE}üóÇÔ∏è  Registry Images:${NC}"
        docker images "$REGISTRY/$SERVICE" --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedSince}}" 2>/dev/null || echo "No registry images found locally"
        ;;
    
    clean)
        echo -e "${YELLOW}üßπ Cleaning up old service images...${NC}"
        # Keep last 5 local images
        OLD_IMAGES=$(docker images "$SERVICE" --format "{{.Repository}}:{{.Tag}}" | tail -n +6)
        if [[ -n "$OLD_IMAGES" ]]; then
            echo "$OLD_IMAGES" | xargs docker rmi
            echo -e "${GREEN}‚úÖ Cleaned up old images${NC}"
        else
            echo -e "${BLUE}üìù No old images to clean${NC}"
        fi
        ;;
    
    actions)
        if ! check_gh_cli; then
            exit 1
        fi
        
        case "${2}" in
            status)
                echo -e "${PURPLE}üîÑ Pipeline Status${NC}"
                echo "=================="
                gh run list --limit 1 --json status,conclusion,displayTitle,createdAt,htmlUrl --template '
                {{- range . -}}
                üîç Status: {{.status}}
                üéØ Result: {{.conclusion}}
                üìù Title: {{.displayTitle}}
                üïí Started: {{.createdAt}}
                üîó URL: {{.htmlUrl}}
                {{- end -}}'
                ;;
            logs)
                RUN_ID="${3}"
                if [[ -z "$RUN_ID" ]]; then
                    RUN_ID=$(gh run list --limit 1 --json databaseId --jq '.[0].databaseId')
                fi
                echo -e "${BLUE}üìú Fetching logs for run $RUN_ID...${NC}"
                gh run view "$RUN_ID" --log
                ;;
            summary)
                echo -e "${PURPLE}üìä Pipeline Health Summary${NC}"
                echo "============================"
                echo -e "${BLUE}Last 10 runs:${NC}"
                gh run list --limit 10 --json status,conclusion --jq '
                "\(‚úÖ Success: \(map(select(.conclusion == "success")) | length))" ,
                "\(‚ùå Failed: \(map(select(.conclusion == "failure")) | length))" ,
                "\(üü° Pending: \(map(select(.status == "in_progress" or .status == "queued")) | length))"
                '
                ;;
            --watch)
                echo -e "${PURPLE}üëÄ Watching ecosystem CI/CD pipelines...${NC}"
                gh run watch
                ;;
            *)
                echo -e "${PURPLE}üîÑ Recent Workflow Runs${NC}"
                echo "========================="
                echo ""
                echo -e "${BLUE}üìä Last 10 runs:${NC}"
                gh run list --limit 10
                echo ""
                echo -e "${YELLOW}üí° Commands: status | logs [run_id] | summary | --watch${NC}"
                ;;
        esac
        ;;
    
    validate)
        echo -e "${YELLOW}üîç Running full environment validation...${NC}"
        run_validation
        ;;
    
    help|--help|-h)
        show_help
        ;;
    
    *)
        show_help
        ;;
esac